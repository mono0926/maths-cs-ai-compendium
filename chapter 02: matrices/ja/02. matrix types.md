# 行列の種類 (Matrix Types)

- すべての行列が同じというわけではありません。特定の構造を持つ行列には、計算を高速化したり、推論を容易にしたり（あるいはその両方）する特別な性質があります。ここでは、よく遭遇する行列の種類を紹介します。

- **正方行列 (square matrix)** は、行数と列数が等しい（$n \times n$）行列です。行列式、固有値、逆行列といった興味深い性質の多くは、正方行列にのみ適用されます。

- **単位行列 (identity matrix)** $I$ は、対角成分が 1 で、それ以外がすべて 0 の正方行列です。これは「何もしない」変換に相当します。任意の適合する行列 $A$ に対して、$AI = IA = A$ が成り立ちます。

```math
I = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}
```

- **ゼロ行列 (zero matrix)** $O$ は、すべての要素が 0 の行列です。これはすべてのベクトルをゼロベクトルに写し、すべての情報を破壊します。

- **対角行列 (diagonal matrix)** は、主対角線以外の要素がすべて 0 の行列です。ベクトルに対角行列を掛けることは、各成分を個別にスケーリングすることに相当し、非常に効率的な計算が可能です。

```math
D = \begin{bmatrix} 3 & 0 \\ 0 & 7 \end{bmatrix}
```

- **対称行列 (symmetric matrix)** は、自身の転置と等しい行列です：$A = A^T$、つまり $A_{ij} = A_{ji}$ です。対称行列には、その固有ベクトルが常に互いに直交するという特別な性質があります。共分散行列は常に対称行列になります。

```math
S = \begin{bmatrix} 3 & -1 \\ -1 & 6 \end{bmatrix}
```

- **三角行列 (triangular matrix)** は、対角線の一方の側の要素がすべて 0 の行列です。**下三角行列 (lower triangular matrix)** は対角線より上が 0、**上三角行列 (upper triangular matrix)** は対角線より下が 0 です。これらは、前進代入や後退代入を通じて連立方程式を効率的に解くために不可欠です。

```math
L = \begin{bmatrix} 2 & 0 & 0 \\ 1 & 3 & 0 \\ -1 & 2 & 4 \end{bmatrix} \qquad U = \begin{bmatrix} 5 & -1 & 2 \\ 0 & 1 & 3 \\ 0 & 0 & -2 \end{bmatrix}
```

- 三角行列の行列式は、単に対角成分の積になります。

- **直交行列 (orthogonal matrix)** は、転置が逆行列と等しいという性質を持ちます：$Q^TQ = QQ^T = I$。

- これは、転置するだけで変換を「元に戻せる」ことを意味し、計算コストが非常に低いです。直交行列の列ベクトルは正規直交（長さが 1 で、互いに垂直）です。

- **疎行列 (sparse matrix)** は要素のほとんどが 0 である行列、**密行列 (dense matrix)** は要素のほとんどが 0 でない行列です。

![疎行列 vs 密行列：点は非ゼロ要素を表す](../../images/sparse_dense.svg)

- 実際には、現実世界の多くの行列は非常に疎です。

- 100万人のユーザーがいるソーシャルネットワークは $10^6 \times 10^6$ の行列で表現できますが、各ユーザーは一握りの人としかつながっていないため、ほとんどの要素は 0 になります。

![小さなソーシャルネットワークとその隣接行列：ほとんどの要素が 0](../../images/social_network_matrix.svg)

- **置換行列 (permutation matrix)** は、単位行列の行を並べ替えることで得られます。これをベクトルに掛けることで、ベクトルの要素をシャッフルできます。各行および各列には、ちょうど一つの 1 があり、他はすべて 0 です。

- 例えば、以下の行列は要素 3 を 1 番目へ、要素 1 を 2 番目へ、要素 2 を 3 番目へと移動させます：

```math
P = \begin{bmatrix} 0 & 0 & 1 \\ 1 & 0 & 0 \\ 0 & 1 & 0 \end{bmatrix}
```

- **テプリッツ行列 (Toeplitz matrix)** は、各対角線（左上から右下）に沿って同じ値が並ぶ行列です：

```math
T = \begin{bmatrix} a & b & c \\ d & a & b \\ e & d & a \end{bmatrix}
```

- この構造は、固定フィルタを信号に沿ってスライドさせることがテプリッツ行列との積に等しいため、信号処理や畳み込み（コンボリューション）において現れます。

- **巡回行列 (circulant matrix)** は、各行が一つ上の行を巡回シフトしたものになっている特別なテプリッツ行列です。行が末尾に達すると、先頭に戻ります：

```math
C = \begin{bmatrix} 1 & 3 & 2 \\ 2 & 1 & 3 \\ 3 & 2 & 1 \end{bmatrix}
```

- 巡回行列は離散フーリエ変換 (DFT) と密接に関連しており、巡回畳み込みの仕組みにおいて中心的な役割を果たします。

- **エルミート行列 (Hermitian matrix)** は、対称行列の複素数版です：$A = A^\ast$（ここで $A^\ast$ は随伴行列、つまり複素共役転置を表します）。

- 実数行列の場合、エルミート行列と対称行列は同じものです。これらは量子計算や信号処理で遭遇します。

- **ユニタリ行列 (unitary matrix)** は、直交行列の複素数版です：$U^\ast U = UU^\ast = I$。直交行列が実空間において長さを保存するように、ユニタリ行列は複素空間において長さを保存します。

- **冪等行列 (idempotent matrix)** は $A^2 = A$ を満たす行列です。変換を2回適用しても、1回適用したのと結果が変わらないため、これは **射影 (projection)** を表します。一度射影してしまえば、再度射影しても何も変わりません。

- **冪零行列 (nilpotent matrix)** は、ある累乗 $k$ に対して $A^k = O$（ゼロ行列）となる行列です。変換を十分に繰り返すと、すべてが 0 に崩壊します。例：

```math
\begin{bmatrix} 0 & 1 \\ 0 & 0 \end{bmatrix}^2 = \begin{bmatrix} 0 & 0 \\ 0 & 0 \end{bmatrix}
```

- **ブール行列 (Boolean matrix)**（またはバイナリ行列）は、0 と 1 のみを含む行列です。これはい、いいえの関係を表します。例えば、3つのノードを持つグラフにおいて、**隣接行列 (adjacency matrix)** はどのノードが接続されているかを記録します：

```math
B = \begin{bmatrix} 0 & 1 & 1 \\ 1 & 0 & 0 \\ 1 & 0 & 0 \end{bmatrix}
```

- ここでは、ノード 1 はノード 2 と 3 に接続されていますが、ノード 2 と 3 は互いに接続されていません。

- **ヴァンデルモンド行列 (Vandermonde matrix)** は、一連の値の連続する累乗から構築されます。与えられた値を $x_1, x_2, x_3$ とすると：

```math
V = \begin{bmatrix} 1 & x_1 & x_1^2 \\ 1 & x_2 & x_2^2 \\ 1 & x_3 & x_3^2 \end{bmatrix}
```

- この構造は、与えられた点を通る一意の多項式を見つけるための多項式補間において現れます。

- **ヘッセンベルグ行列 (Hessenberg matrix)** は「ほぼ」三角行列で、第1副対角線より下の要素がすべて 0 です：

```math
H = \begin{bmatrix} 4 & 2 & 1 \\ 3 & 5 & -1 \\ 0 & 1 & 6 \end{bmatrix}
```

- これは、固有値を効率的に計算するための有用な中間形式です。行列をまずヘッセンベルグ形式に落とし込むことで、反復アルゴリズムの収束を早めることができます。

## コーディング課題 (CoLab または notebook を使用)

1. 直交行列（回転行列）を作成し、その転置行列との積を求め、単位行列が得られることを確認してください。異なる角度で試してみてください。

```python {cmd=true}
import jax.numpy as jnp

theta = jnp.pi / 4
Q = jnp.array([[jnp.cos(theta), -jnp.sin(theta)],
               [jnp.sin(theta),  jnp.cos(theta)]])

print(f"Q @ Q.T:\n{Q @ Q.T}")
print(f"Determinant: {jnp.linalg.det(Q):.2f}")
```

2. 対称行列を作成し、それが自身の転置と等しいことを確認してください。その後、その固有値を計算し、固有ベクトルが互いに垂直であることを確認してください。

```python {cmd=true}
import jax.numpy as jnp

S = jnp.array([[4.0, 2.0],
               [2.0, 3.0]])

print(f"Symmetric: {jnp.allclose(S, S.T)}")

eigenvalues, eigenvectors = jnp.linalg.eigh(S)
print(f"Eigenvalues: {eigenvalues}")
print(f"Dot product of eigenvectors: {jnp.dot(eigenvectors[:, 0], eigenvectors[:, 1]):.6f}")
```
