# 線形変換 (Linear Transformations)

- **線形変換 (linear transformation)**（あるいは線形写像）とは、ベクトルを受け取って別のベクトルを生成する関数であり、加算とスケーリングの性質を保持するものです。$T$ が線形であるなら、以下が成り立ちます：
  - $T(\mathbf{u} + \mathbf{v}) = T(\mathbf{u}) + T(\mathbf{v})$
  - $T(c\mathbf{u}) = cT(\mathbf{u})$

- すべての線形変換は、行列との積として表現できます。行列こそが変換そのものであると言えます。ベクトルに行列を掛けることは、そのベクトルに線形変換を適用することと同義です。

- $2 \times 2$ 行列を、2次元ベクトルを入力として受け取り、新しい2次元ベクトルを出力する「機械」と考えてみてください。行列の列ベクトルは、標準基底ベクトル $\hat{\mathbf{i}}$ と $\hat{\mathbf{j}}$ が変換後にどこに移動するかを教えてくれます。それ以外のすべてのベクトルの行き先は、線形性から自ずと決まります。

![行列の列は基底ベクトルの着地点を示す](../images/basis_transform.svg)

- 例えば、もし

```math
A = \begin{bmatrix} 2 & 1 \\ 1 & 2 \end{bmatrix}
```

であれば、$\hat{\mathbf{i}} = [1, 0]^T$ は $[2, 1]^T$（第1列）へ、$\hat{\mathbf{j}} = [0, 1]^T$ は $[1, 2]^T$（第2列）へと移動します。他のすべてのベクトルはこれら2つの基底の組み合わせで表現できるため、出力も自動的に決まります。

- 2つの行列を掛けることは、一つの変換の後に別の変換を適用すること（合成変換）と考えることができます。ベクトルを $B$ で変換し、その結果をさらに $A$ で変換する場合、$AB$ がその一連の操作を一度に行います。ゲームエンジンにおいて、キャラクターを回転させてから前進させるのと、前進させてから回転させるのとでは結果が異なります。これが行列の積が非可換である理由です。

- **回転 (Rotation)** は、長さを変えずにベクトルを角度 $\theta$ だけ回転させます。ベクトルのサイズは維持され、向きだけが新しくなります。

![回転は長さを維持し、向きを変える](../images/rotation.svg)

- 2次元における回転行列は以下の通りです：

```math
R(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta \\ \sin\theta & \cos\theta \end{bmatrix}
```

- $\theta = 90°$ の場合：

```math
R = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}
```

となり、$[1, 0]^T$ は $[0, 1]^T$ になります。右を向いていたベクトルが上を向くようになります。回転行列は直交行列であり、常に行列式は 1 です。スマートフォンで写真を回転させるとき、まさにこの行列がすべてのピクセル座標に適用されています。

- 3次元では、各軸に対して別々の回転行列があります。ロボットアームが各関節を特定の軸の周りに回転させるとき、各関節が一つの回転行列に対応します。z軸周りの回転は、3次元に組み込まれた2次元のケースのように見えます：

```math
R_z(\theta) = \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta & \cos\theta & 0 \\ 0 & 0 & 1 \end{bmatrix}
```

- **スケーリング (Scaling)** は、各軸に沿って独立にベクトルを拡大または縮小させます：

```math
S(s_x, s_y) = \begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix}
```

![スケーリングは各軸を異なる倍率で伸ばす](../images/scaling.svg)

- $S(2, 1.5)$ はx成分を2倍にし、y成分を1.5倍にします。ある軸に沿って $-1$ 倍することは、その成分を反転させることに相当します。対角行列は常にスケーリング変換を表します。画像を 50% にリサイズするとき、すべてのピクセル座標に $S(0.5, 0.5)$ を適用しています。

- **鏡映 (Reflection)** は、鏡のように軸や直線に対してベクトルを反転させます。x軸に対する鏡映では、x成分を維持し、y成分の符号を反転させます：

```math
\text{Ref}_x = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}
```

![x軸に対する鏡映はy成分を反転させる](../images/reflection.svg)

- 例えば、$[3, 2]^T$ は $[3, -2]^T$ になります。スマートフォンの自撮り写真で文字が正しく読めるように左右を反転させるとき、鏡映行列が適用されています。直線 $y = x$ に対する鏡映は、2つの成分を入れ替えます：

```math
\text{Ref}_{y=x} = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}
```

- 鏡映行列の行列式は $-1$ であり、向き（右向き・左向きなど）が反転することを示しています。

- 回転と鏡映は、どちらも **剛体変換 (rigid transformation)** です。これらは距離と角度を保存します。これらを表現する行列は直交行列であり、直交行列の行列式が必ず $+1$（回転）または $-1$（鏡映）になるのはそのためです。

- **剪断（せん断、Shearing）** は、一方の軸に沿って、もう一方の軸の距離に比例してベクトルを歪ませます。係数 $k$ による水平方向の剪断：

```math
\text{Sh}_x(k) = \begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix}
```

![剪断は下部を固定したまま上部を横にスライドさせる](../images/shearing.svg)

- 各点は、その高さの $k$ 倍だけ水平にスライドします。$k = 0.5$ の場合、高さ 2 にある点は右に 1 シフトします。下端は動かず、上端ほど大きくスライドします。これは斜体（イタリック）文字の仕組みと同じです。直立した文字を右側に傾くように剪断 transformation を適用しています。

- これまで述べたもの（回転、スケーリング、鏡映、剪断）はすべて **線形** 変換です。これらは原点を固定し、直線を直線のまま保ちます。では、**平行移動 (translation)**（すべてを一定量だけ動かす）はどうでしょうか？

- 平行移動は、原点を移動させてしまうため、厳密には線形変換ではありません。すべての点を右に 3 だけシフトさせると、ゼロベクトルが $[3, 0]^T$ に移動してしまい、線形性が崩れます。これを扱うために、線形変換と平行移動を組み合わせた **アフィン変換 (affine transformation)** を使用します：

$$\mathbf{y} = A\mathbf{x} + \mathbf{t}$$

- これを単一の行列の積として表現するために、**同次座標 (homogeneous coordinates)** を使用します。すべてのベクトルに余分な「1」を付け加え、$(n+1) \times (n+1)$ 行列を使用します：

```math
\begin{bmatrix} A & \mathbf{t} \\ \mathbf{0}^T & 1 \end{bmatrix} \begin{bmatrix} \mathbf{x} \\ 1 \end{bmatrix} = \begin{bmatrix} A\mathbf{x} + \mathbf{t} \\ 1 \end{bmatrix}
```

- アフィン変換は直線性と平行性を保持しますが、角度や長さが保持されるとは限りません。ビデオゲーム内のすべてのオブジェクトはアフィン変換を使って配置されています。回転させ、スケールを変え、適切な場所へ配置する。これらすべてが一つの行列にエンコードされます。

- **退化変換 (degenerate transformation)**（特異行列による変換）は、空間をより低い次元へと押しつぶします。

- 例えば、行列

```math
\begin{bmatrix} 1 & 2 \\ 2 & 4 \end{bmatrix}
```

は、2次元ベクトルをすべて一本の直線上に写します。これは両方の列ベクトルが同じ方向を向いているためです。行列式はゼロになり、情報が失われるため、変換を元に戻すことはできません。

- カラー画像（1ピクセルあたり赤・緑・青の3つの値）をグレースケール（1ピクセルあたり1つの値）に変換することは、退化変換の一種です。色の情報は永久に失われます。

- MLにおいて、線形変換はニューラルネットワークの核心です。データは行列（人間、飛行機、テキスト、画像など、あらゆる物事の特徴を表すベクトルの積み重ね）として表現されます。

- 各層は行列の積（線形変換）を適用します。詳細は他の章で説明しますが、これらのデータをどのように構造化し、ニューラルネットワークを適切に動機づけるかを説明する必要があります。

- しかし、今日最も使われている手法の多くは、ほとんど排他的にデータを一連の線形変換に通すものです。これらを **Transformer** と呼びます。

- Gemini, ChatGPT, Claude, Qwen, DeepSeek、そして今日世界で最高の性能を発揮している AI たちは、すべて Transformer なのです！

## コーディング課題 (CoLab または notebook を使用)

1. 回転行列をベクトルに適用し、元のベクトルと回転後のベクトルの両方をプロットしてください。異なる角度で試してみてください。

```python
import jax.numpy as jnp
import matplotlib.pyplot as plt

theta = jnp.pi / 3
R = jnp.array([[jnp.cos(theta), -jnp.sin(theta)],
               [jnp.sin(theta),  jnp.cos(theta)]])

v = jnp.array([1.0, 0.0])
v_rot = R @ v

plt.figure(figsize=(5, 5))
plt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='red', label='original')
plt.quiver(0, 0, v_rot[0], v_rot[1], angles='xy', scale_units='xy', scale=1, color='blue', label='rotated')
plt.xlim(-1.5, 1.5); plt.ylim(-1.5, 1.5)
plt.grid(True); plt.legend(); plt.gca().set_aspect('equal')
plt.show()
```

2. 正方形を形成する点集合に剪断変換を適用し、変形した形状を可視化してください。

```python
import jax.numpy as jnp
import matplotlib.pyplot as plt

square = jnp.array([[0,0],[1,0],[1,1],[0,1],[0,0]]).T

k = 0.5
shear = jnp.array([[1, k],
                    [0, 1]])
sheared = shear @ square

plt.figure(figsize=(6, 4))
plt.plot(square[0], square[1], 'r-o', label='original')
plt.plot(sheared[0], sheared[1], 'b-o', label='sheared')
plt.grid(True); plt.legend(); plt.gca().set_aspect('equal')
plt.show()
```
