# 積分学 (Integral Calculus)

- 微分は、ある1点における変化率を教えてくれます。積分（積分法）はその逆で、多くの小さな断片を積み重ねて合計を計算します。

- 微分が「どのくらいの速さか？」という問いに答えるなら、積分は「どれだけの量か？」という問いに答えます。

- 積分を考える最も単純な方法は、**曲線の下側の面積** として捉えることです。関数 $f(x)$ をプロットし、$x = a$ から $x = b$ までの曲線と x 軸の間の領域を塗りつぶすと、積分はその領域の符号付き面積を与えます。

![積分は細長い長方形を合計することで曲線の下側の面積を計算する](../images/area_under_curve.svg)

- なぜ「符号付き」なのでしょうか？ x 軸より上の領域は正の面積として寄与し、x 軸より下の領域は負の面積として寄与します。これは物理学的にも理にかなっています。$f(x)$ が速度を表す場合、積分は（前後を合わせた）正味の変位を計算するのであって、総移動距離ではありません。

- この面積を計算するために、領域を幅 $\Delta x$ の $n$ 個の細い垂直な長方形に分割することを想像してください。各長方形の高さは、そのスライス内のいずれかの点における関数の値です。それらを合計します：

$$\text{Area} \approx \sum_{i=1}^{n} f(x_i^\ast) \, \Delta x$$

- 長方形をどんどん細くしていく（$n \to \infty, \Delta x \to 0$）と、合計は正確な値になります。この極限プロセスが **定積分 (definite integral)** を定義します：

$$\int_a^b f(x)\, dx = \lim_{n \to \infty} \sum_{i=1}^{n} f(x_i^\ast) \, \Delta x$$

- $\int$ 記号は「合計 (Sum)」を意味する $S$ を引き伸ばしたものです。$dx$ は、x 軸に沿って無限に薄いスライスを合計していることを思い出させてくれます。

- **不定積分 (indefinite integral)**（または **原始関数 (antiderivative)**）は、その導関数が $f(x)$ になるような関数 $F(x)$ です。次のように記述します：

$$\int f(x)\, dx = F(x) + C$$

- $+ C$ は **積分定数 (constant of integration)** です。定数の微分は常にゼロなので、定数だけが異なる原始関数は無限に存在します。例えば、$\int 2x\, dx = x^2 + C$ です。なぜなら、$x^2 + 7$ や $x^2 - 3$ の微分も同様に $2x$ になるからです。

- **微分積分学の基本定理 (Fundamental Theorem of Calculus)** は、微分と積分を結びつける架け橋です。これには2つの部分があります：

- **第1部**: $F(x)$ が $f(x)$ の原始関数である場合、定積分は両端における $F$ の値の差に等しくなります：

$$\int_a^b f(x)\, dx = F(b) - F(a)$$

- これは非常に実用的です。合計の極限を計算する（これは困難です）代わりに、原始関数を見つけてそれを2つの点で評価する（これは通常容易です）だけで済みます。

- **第2部**: $F(x) = \int_a^x f(t)\, dt$ と定義すると、$F'(x) = f(x)$ となります。微分と積分は逆演算であり、互いに打ち消し合います。

- 例えば、$\int_1^3 x^2\, dx$ を計算する場合：$x^2$ の原始関数は $\frac{x^3}{3}$ です。したがって、$\int_1^3 x^2\, dx = \frac{27}{3} - \frac{1}{3} = \frac{26}{3} \approx 8.67$ となります。

- 微分にルールがあるように、積分にもそれらを逆にした対応するルールがあります：

| 関数          | 積分                      | 条件        |
| ------------- | ------------------------- | ----------- | ---- | --- |
| $x^n$         | $\frac{x^{n+1}}{n+1} + C$ | $n \neq -1$ |
| $\frac{1}{x}$ | $\ln                      | x           | + C$ |     |
| $e^x$         | $e^x + C$                 |             |
| $a^x$         | $\frac{a^x}{\ln a} + C$   |             |
| $\sin x$      | $-\cos x + C$             |             |
| $\cos x$      | $\sin x + C$              |             |
| $k$（定数）   | $kx + C$                  |             |

- **和/差のルール** も同様です：$\int [f(x) \pm g(x)]\, dx = \int f(x)\, dx \pm \int g(x)\, dx$。定数は外に出すことができます：$\int k\, f(x)\, dx = k \int f(x)\, dx$。

- 関数が直接積分するには複雑すぎる場合、それを簡略化するテクニックがあります。

- **置換積分 (u-substitution)** は連鎖律の逆です。合成関数 $f(g(x))$ に $g'(x)$ が掛け合わされているのを見つけたら、$u = g(x)$ と置くことで $du = g'(x)\, dx$ となり、積分が単純化されます。

- 例えば：$\int 2x \cos(x^2)\, dx$。$u = x^2$ とすると、$du = 2x\, dx$ です。積分は $\int \cos(u)\, du = \sin(u) + C = \sin(x^2) + C$ となります。

- **部分積分 (Integration by parts)** は積の微分の逆です。被積分関数が2つの関数の積である場合：

$$\int u\, dv = uv - \int v\, du$$

- 残りの積分 $\int v\, du$ が元の積分よりも単純になるように、$u$ と $dv$ を戦略的に選択します。$u$ の選び方の一般的な覚え方は **LIATE** です：対数 (Logarithmic)、逆三角関数 (Inverse trig)、代数 (Algebraic)、三角関数 (Trigonometric)、指数 (Exponential) の順に優先して $u$ に選びます。

- 例えば：$\int x\, e^x\, dx$。$u = x$（代数）、$dv = e^x\, dx$ とします。すると、$du = dx, v = e^x$ なので：$\int x\, e^x\, dx = x\, e^x - \int e^x\, dx = x\, e^x - e^x + C = e^x(x - 1) + C$ となります。

- ML において積分は、確率論（密度関数を積分して確率を計算する）、期待値（連続分布にわたる加重平均）、および ROC 曲線の面積（AUC）の計算などに登場します。実際に手で積分することは稀ですが、積分の意味を理解しておくことは、これらの量を解釈するのに役立ちます。

## コーディングタスク (CoLab または notebook を使用)

1. 長方形の数を増やしながらリーマン和を使用し、$\int_0^1 x^2\, dx$ を数値的に近似します。正確な解である $\frac{1}{3}$ と比較してください。

```python {cmd=true}
import jax.numpy as jnp

for n in [10, 100, 1000, 10000]:
    x = jnp.linspace(0, 1, n, endpoint=False)
    dx = 1.0 / n
    area = jnp.sum(x**2 * dx)
    print(f"n={n:5d}  approx: {area:.6f}  exact: {1/3:.6f}")
```

2. 微分積分学の基本定理を数値的に検証します。$F(x) = \int_0^x t^2\, dt = \frac{x^3}{3}$ を定義し、その導関数（`jax.grad` で計算）が $x^2$ に等しいことを確認してください。

```python {cmd=true}
import jax
import jax.numpy as jnp

F = lambda x: x**3 / 3
dF = jax.grad(F)

for x in [0.5, 1.0, 2.0, 3.0]:
    print(f"x={x:.1f}  F'(x)={dF(x):.4f}  x^2={x**2:.4f}")
```

3. 0 から $\pi$ までの $f(x) = \sin(x)$ の下側の面積を可視化します。`plt.fill_between` を使用して面積を塗りつぶし、リーマン和で数値的に計算します。

```python {cmd=true}
import jax.numpy as jnp
import matplotlib.pyplot as plt

x = jnp.linspace(0, jnp.pi, 500)
y = jnp.sin(x)

plt.plot(x, y, color="purple", linewidth=2)
plt.fill_between(x, y, alpha=0.2, color="purple")
plt.title(f"Area = {jnp.sum(jnp.sin(x) * (jnp.pi / 500)):.4f}  (exact: 2.0)")
plt.show()
```
