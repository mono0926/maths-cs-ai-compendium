# 計数 (Counting)

- 確率を計算する前に、まず「起こりうる結果」を数え上げる必要があります。ポーカーで勝利する役を引く確率を知りたいなら、まず可能な手札がいくつ存在し、そのうちいくつが勝利の手札なのかを知る必要があります。「計数 (Counting)」は、確率を精密なものにするための装置です。

- 最もシンプルな数え上げの原則は **積の法則 (multiplication rule)** です。ある決定に $m$ 個の選択肢があり、2つ目の独立した決定に $n$ 個の選択肢がある場合、組み合わされた結果の総数は $m \times n$ になります。

- 朝、服を選ぶ場面を想像してください。シャツが3枚、ズボンが4本あります。どのシャツもどのズボンとも組み合わせることができるため、可能なコーディネートは $3 \times 4 = 12$ 通りになります。

![3つのシャツと4つのズボンの組み合わせが12通りであることを示す樹形図](../images/counting_outfits.svg)

- 積の法則は、選択肢がいくつあっても適用できます。さらに靴が2足あるなら、合計の組み合わせは $3 \times 4 \times 2 = 24$ になります。新しい独立した選択肢が増えるたびに、その数は掛け合わされていきます。

- **和の法則 (addition rule)** は、「または (or)」のシナリオを扱います。イベントAが $m$ 通り、イベントBが $n$ 通りの方法で起こり、かつそれらが同時に起こり得ない（互いに排他的である）場合、総数は $m + n$ になります。

- 都市Xから都市Yへ行くのに、車（3ルート）または電車（2ルート）が使えるとします。両方を同時に選ぶことはできないため、合計の選択肢は $3 + 2 = 5$ 通りです。

- イベントが重なる場合は、二重にカウントされた結果を差し引く必要があります。$A$ と $B$ が同時に起こり得る場合、総数は $|A \cup B| = |A| + |B| - |A \cap B|$ となります。これは **包含排除の原理 (inclusion-exclusion principle)** といい、確率の加法定理を議論する際に再び登場します。

- 非負の整数 $n$ の **階乗 (factorial)** は、$n$ までのすべての正の整数の積です：

$$n! = n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1$$

- 階乗は、「$n$ 個の異なるオブジェクトを一列に並べる方法は何通りあるか？」という問いに答えるものだと考えてください。本棚にある3冊の本は、$3! = 3 \times 2 \times 1 = 6$ 通りの方法で並べることができます。なお、定義により $0! = 1$ です。

- 階乗の増加は極めて高速です。$10! = 3,628,800$ であり、$20!$ はすでに $2.4 \times 10^{18}$ を超えます。この爆発的な増加こそが、組み合わせ問題において総当たり検索（ブルートフォース）が非現実的になる理由です。

- **順列 (permutation)** は、オブジェクトを順序を考慮して並べたものです。$n$ 個の異なるオブジェクトから $r$ 個を選び、その順序が重要である場合、順列の数は次のようになります：

$$P(n, r) = \frac{n!}{(n - r)!}$$

- 10人のメンバーがいるクラブから、会長、副会長、会計を選ぶところを想像してください。最初の役職には10人の候補がおり、2番目には残りの9人、3番目には8人が候補となります。これにより $P(10, 3) = 10 \times 9 \times 8 = 720$ 通りとなります。公式でも $\frac{10!}{7!} = 720$ と確認できます。

- **組合せ (combination)** は、順序を問わない選択です。$n$ 個から $r$ 個を選び、順序が関係ない場合、重複する並び順を除外します：

$$C(n, r) = \binom{n}{r} = \frac{n!}{r!(n - r)!}$$

- 記号 $\binom{n}{r}$ は「n choose r」と読みます（日本語ではよく $_nC_r$ と書かれます）。重要な洞察は、すべての組合せが $r!$ 通りの順列に対応している（選ばれた $r$ 個のアイテムは $r!$ 通りに並べ替え可能である）ということです。そのため、順列の数を $r!$ で割ることで組合せの数を求めます。

![順列（すべての並びを数える）と組合せ（同一グループをまとめる）の比較](../images/permutation_vs_combination.svg)

- 例：10人のグループから、3人の委員会を作る方法は何通りあるでしょうか。順序は関係ない（会長や副会長のような役職はなく、単なるメンバーとしての選出）ため、組合せを使用します：

$$\binom{10}{3} = \frac{10!}{3! \cdot 7!} = \frac{10 \times 9 \times 8}{3 \times 2 \times 1} = 120$$

- 同じ10人でも、順列なら720通りですが、組合せなら120通りになります。これは、3人の各グループに対して $3! = 6$ 通りの内部的な並び順があるためです。

- 組合せは確率論において中心的な役割を果たします。二項係数 $\binom{n}{r}$ は、$n$ 回の試行でちょうど $r$ 回成功する方法の数をカウントします。これは二項分布（ファイル 03 で詳しく扱います）の核心となります。

- 複数の計数アイデアを組み合わせた、古典的な委員会問題を解いてみましょう。

- **問題**：あるクラブに男性8人と女性6人がいます。男性3人と女性2人をちょうど含む5人の委員会を作る方法は、何通りあるでしょうか。

- **ステップ 1**：8人の男性から3人を選びます。

$$\binom{8}{3} = \frac{8!}{3! \cdot 5!} = \frac{8 \times 7 \times 6}{3 \times 2 \times 1} = 56$$

- **ステップ 2**：6人の女性から2人を選びます。

$$\binom{6}{2} = \frac{6!}{2! \cdot 4!} = \frac{6 \times 5}{2 \times 1} = 15$$

- **ステップ 3**：積の法則を適用します。男性の各選択に対して、女性の各選択を組み合わせることができます：

$$56 \times 15 = 840 \text{ 通りの委員会}$$

- 複雑な計数問題を独立した小さな選択に分解し、それらを掛け合わせるというこのパターンは、組合せ論における標準的なアプローチです。

- また、**重複順列 (permutations with repetition)** というものもあります。アイテムを繰り返し選べる場合、$n$ 種類から $r$ 個選ぶと $n^r$ 通りの結果になります。0から9の数字を使った4桁の暗証番号（PIN）は、$10^4 = 10,000$ 通りの可能性があります。各桁に10の選択肢があり、積の法則によって計算されます。

- **重複組合せ (combinations with repetition)** は、「仕切りと丸 (stars and bars)」とも呼ばれ、繰り返しが許され、かつ順序を問わない場合に $n$ 種類から $r$ 個選ぶ方法の数を数えます：

$$\binom{n + r - 1}{r} = \frac{(n + r - 1)!}{r!(n - 1)!}$$

- 例：4種類のアイスクリームから3スクープ選ぶ（重複を許す）場合、$\binom{4 + 3 - 1}{3} = \binom{6}{3} = 20$ 通りの選択肢があります。

- 計数ツールのまとめ：

| シナリオ                    | 公式                                 |
| --------------------------- | ------------------------------------ |
| 順序あり、重複なし (順列)   | $P(n,r) = \frac{n!}{(n-r)!}$         |
| 順序なし、重複なし (組合せ) | $\binom{n}{r} = \frac{n!}{r!(n-r)!}$ |
| 順序あり、重複あり          | $n^r$                                |
| 順序なし、重複あり          | $\binom{n+r-1}{r}$                   |

- 同様に確からしい結果を含むすべての確率計算では、公式 $P(\text{イベント}) = \frac{\text{該当する結果の数}}{\text{すべての結果の数}}$ を使用します。計数によって、これら両方の数値を導き出すことができます。この基礎を固めた上で、次のファイルで確率そのものを定式化していきましょう。

## コーディングタスク (CoLab または notebook を使用)

1. 階乗公式と直接計算の両方を使用して、$P(10, 3)$ と $\binom{10}{3}$ を計算してください。順列の数は常に組合せの数の $r!$ 倍であることを確認してください。

```python
import jax.numpy as jnp
from math import factorial

n, r = 10, 3

perm = factorial(n) // factorial(n - r)
comb = factorial(n) // (factorial(r) * factorial(n - r))

print(f"P({n},{r}) = {perm}")
print(f"C({n},{r}) = {comb}")
print(f"P / C = {perm // comb} (これは {r}! = {factorial(r)} になるはずです)")
```

2. 委員会問題（男性8人から3人、女性6人から2人）をプログラムで解き、すべての有効な委員会を列挙することで検証してください。

```python
from itertools import combinations
from math import factorial

def comb_count(n, r):
    return factorial(n) // (factorial(r) * factorial(n - r))

# 公式によるアプローチ
men_ways = comb_count(8, 3)
women_ways = comb_count(6, 2)
print(f"公式: {men_ways} × {women_ways} = {men_ways * women_ways}")

# 列挙によるアプローチ
men = [f"M{i}" for i in range(1, 9)]
women = [f"W{i}" for i in range(1, 7)]
count = sum(1 for _ in combinations(men, 3) for _ in combinations(women, 2))
print(f"列挙: {count}")
```

3. 26個の小文字から（重複を許して）作れる4文字のパスワードがいくつあるか数えてください。次に、重複する文字を含まないパスワードがいくつあるか数えてください。

```python
from math import factorial

n = 26
r = 4

with_rep = n ** r
without_rep = factorial(n) // factorial(n - r)

print(f"重複あり:    {with_rep:>10,}")
print(f"重複なし:    {without_rep:>10,}")
print(f"重複がある割合: {1 - without_rep/with_rep:.2%}")
```

4. 誕生日問題をシミュレートしてください：$k$ 人のグループにおいて、少なくとも2人が同じ誕生日である確率はどれくらいでしょうか。$k = 1$ から $60$ まで確率をプロットし、50% を超えるポイントを見つけてください。

```python
import jax
import jax.numpy as jnp
import matplotlib.pyplot as plt

def birthday_prob_exact(k):
    """k 人のグループで少なくとも1組が同じ誕生日である確率"""
    p_no_match = 1.0
    for i in range(k):
        p_no_match *= (365 - i) / 365
    return 1 - p_no_match

ks = list(range(1, 61))
probs = [birthday_prob_exact(k) for k in ks]

plt.figure(figsize=(8, 4))
plt.plot(ks, probs, color="#3498db", linewidth=2)
plt.axhline(y=0.5, color="#e74c3c", linestyle="--", alpha=0.7, label="50%")
cross = next(k for k, p in zip(ks, probs) if p >= 0.5)
plt.axvline(x=cross, color="#e74c3c", linestyle="--", alpha=0.7)
plt.xlabel("グループサイズ (k)")
plt.ylabel("P(少なくとも1組が同じ誕生日)")
plt.title(f"誕生日問題 (k={cross} で 50% を超える)")
plt.legend()
plt.grid(alpha=0.3)
plt.show()
```
