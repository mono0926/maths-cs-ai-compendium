# 距離とノルム (Metrics and Norms)

- ベクトルには大きさと方向があることは分かりました。しかし、単一のベクトルが「どれくらい大きい」か、あるいは2つのベクトルが「どれくらい離れている」かを、実際にどのように測定すればよいのでしょうか？ここで **ノルム (norms)** と **距離 (metrics)** が登場します。

- スカラーの場合、値自体が量を表すため、10 > 5 のように比較できます。では、ベクトルをどのように定量化すればよいでしょうか？それが **ノルム** です。ノルムは単一のベクトルのサイズを測定します。

- 最も馴染み深いノルムは **ユークリッドノルム** (L2ノルム) です。これは私たちが既に知っている大きさの公式そのものです：

$$\|\mathbf{v}\|_2 = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2}$$

- しかし、サイズを測る方法は他にもあります。格子状に道が走る都市にいると想像してください。建物を斜めに通り抜けることはできないため、旅の「長さ」は各通りに沿って歩いたブロックの合計になります。これが **マンハッタンノルム** (L1ノルム) です：

$$\|\mathbf{v}\|_1 = |v_1| + |v_2| + \cdots + |v_n|$$

- あるいは、他の成分は無視して、単一の最大成分だけに注目したい場合もあります。これが **最大ノルム** (L∞ノルム) です：

$$\|\mathbf{v}\|_\infty = \max(|v_1|, |v_2|, \ldots, |v_n|)$$

- これら3つはすべて、**一般Lpノルム** の特殊なケースです：

$$\|\mathbf{v}\|_p = (|v_1|^p + |v_2|^p + \cdots + |v_n|^p)^{1/p}$$

- $p = 2$ とするとユークリッドノルム、$p = 1$ とするとマンハッタンノルムになり、$p \to \infty$ とすると最大ノルムになります。$p$ が大きくなるにつれて、最大成分の寄与がどんどん大きくなり、最終的には最大成分だけが意味を持つようになります。

- すべてのノルムは3つのルールに従わなければなりません：
  - **非負性 (Non-negativity)**: $\|\mathbf{v}\| \geq 0$ であり、$\|\mathbf{v}\| = 0$ となるのは $\mathbf{v} = \mathbf{0}$ の場合のみ。サイズが負になることはなく、零ベクトルのみがサイズゼロを持ちます。

  - **斉次性 (Scaling)**: $\|c\mathbf{v}\| = |c| \cdot \|\mathbf{v}\|$。ベクトルを2倍にすると、そのサイズも2倍になります。

  - **三角不等式 (Triangle inequality)**: $\|\mathbf{u} + \mathbf{v}\| \leq \|\mathbf{u}\| + \|\mathbf{v}\|$。近道（直進）は、遠回り（個別に足す）よりも長くなることはありません。

- 次に、**距離 (metric)** は2つのベクトル _の間_ の隔たりを測定します。「これら2つの点はどれくらい離れているか？」という問いに答えるものだと考えてください。

- 最も単純な距離の求め方は、差のベクトルに対してノルムを使用することです： $d(\mathbf{u}, \mathbf{v}) = \|\mathbf{u} - \mathbf{v}\|$。2つのベクトルの差を取り、残ったもののサイズを測ります。

- ユークリッドノルムを使用すると、おなじみの **ユークリッド距離** が得られます：

$$d(\mathbf{u}, \mathbf{v}) = \sqrt{(u_1 - v_1)^2 + (u_2 - v_2)^2 + \cdots + (u_n - v_n)^2}$$

- マンハッタンノルムを使用すると **マンハッタン距離** が得られます。これは各軸に沿った差の合計であり、2地点間の都市ブロックを数えるようなものです。

- すべての距離（距離関数）は4つのルールに従わなければなりません：
  - **非負性 (Non-negativity)**: $d(\mathbf{u}, \mathbf{v}) \geq 0$。距離が負になることはありません。

  - **同一性 (Identity)**: $d(\mathbf{u}, \mathbf{v}) = 0$ であることと $\mathbf{u} = \mathbf{v}$ であることは同値。距離がゼロということは、同じ点であることを意味します。

  - **対称性 (Symmetry)**: $d(\mathbf{u}, \mathbf{v}) = d(\mathbf{v}, \mathbf{u})$。AからBへの距離は、BからAへの距離と同じです。

  - **三角不等式 (Triangle inequality)**: $d(\mathbf{u}, \mathbf{w}) \leq d(\mathbf{u}, \mathbf{v}) + d(\mathbf{v}, \mathbf{w})$。目的地へ直接行くことは、寄り道をして行くよりも長くなることはありません。

- では、これら2つの関係はどうなっているのでしょうか？ノルムは1つのベクトルを測定し、距離は2つの間のギャップを測定します。すべてのノルムは（差を測ることで）自然に距離を作成しますが、すべての距離がノルムから来ているわけではありません。

- 例えば、**ハミング距離 (Hamming distance)** は、2つのベクトルが異なる成分の数（位置の数）をカウントします。これは有効な距離関数ですが、いかなるノルムからも導かれません。

- MLにおいて、適切なノルムや距離を選択することは重要です。

- L2距離は合計する前に各差を2乗するため、単一の大きな差が結果を支配（卓越）する傾向があります。

- L1距離は絶対値の差を合計するため、それぞれを等しく扱います。L2と比較して、単一の大きな差の影響が抑えられます。

## コーディング課題 (CoLab または notebook を使用)

1. 同じベクトルについて L1 ノルムと L2 ノルムを計算してください。値を変更してみて、どちらのノルムが「大きな成分」に対してより敏感か、あるいは「多くの小さな成分」に対してより敏感かを確認してください。その後、p の値を増やしながら（例：1, 2, 5, 10, 50, 100）Lp ノルムを計算し、L∞ノルムの値に収束していく様子を観察してください。

```python
import jax.numpy as jnp

v = jnp.array([3.0, -4.0, 1.0])

l1 = jnp.sum(jnp.abs(v))
l2 = jnp.sqrt(jnp.sum(v ** 2))

print(f"L1: {l1}, L2: {l2:.2f}")
```

2. 2つのベクトル間のユークリッド距離とマンハッタン距離を計算してください。ベクトルを近づけたり遠ざけたりしてみて、それぞれの距離がどのように異なった反応を示すか観察してください。

```python
import jax.numpy as jnp

u = jnp.array([1.0, 2.0, 3.0])
v = jnp.array([4.0, 0.0, 1.0])

euclidean = jnp.sqrt(jnp.sum((u - v) ** 2))
manhattan = jnp.sum(jnp.abs(u - v))

print(f"Euclidean: {euclidean:.2f}, Manhattan: {manhattan}")
```
