# ベクトルの積 (Vector Products)

- ベクトルの加算とスカラー倍について見てきました。しかし、2つのベクトルを _掛け合わせる_ ことはできるのでしょうか？実は、掛け合わせる方法は複数あり、それぞれが異なる問いに答えます。

- **内積 (inner product)** はその一般的な概念です。2つのベクトルを受け取り、単一の数値（スカラー）を生成する関数です。これはベクトルを「掛ける」ための抽象的な設計図といえます。

- いかなる内積も、以下の3つのルールを満たさなければなりません：
  - **正定値性 (Positive definiteness)**: $\langle \mathbf{v}, \mathbf{v} \rangle \geq 0$ であり、零ベクトルの場合にのみゼロとなる。ベクトルを自分自身と掛けると、常に非負の結果が得られます。

  - **対称性 (Symmetry)**: $\langle \mathbf{u}, \mathbf{v} \rangle = \langle \mathbf{v}, \mathbf{u} \rangle$。順番は関係ありません。

  - **線形性 (Linearity)**: $\langle a\mathbf{u} + b\mathbf{v}, \mathbf{w} \rangle = a\langle \mathbf{u}, \mathbf{w} \rangle + b\langle \mathbf{v}, \mathbf{w} \rangle$。加算とスカラー倍に対して分配されます。

- **ドット積 (dot product)** は最も一般的な内積です。これは、ほぼすべての場所で使用することになる具体的なバージョンです。2つのベクトル $\mathbf{a} = (a_1, a_2, \ldots, a_n)$ と $\mathbf{b} = (b_1, b_2, \ldots, b_n)$ に対して：

$$\mathbf{a} \cdot \mathbf{b} = a_1 b_1 + a_2 b_2 + \cdots + a_n b_n$$

- 対応する成分同士を掛け合わせ、それをすべて足し合わせる。ただそれだけです。

- では、この数値は何を _意味_ するのでしょうか？ドット積には美しい幾何学的な解釈があります：

$$\mathbf{a} \cdot \mathbf{b} = \|\mathbf{a}\| \, \|\mathbf{b}\| \cos(\theta)$$

![ドット積：ベクトル a が b に投影され、角度 θ と投影が示されている](../images/dot_product.svg)

- これはドット積を、2つのベクトル間の角度 $\theta$ に直接結びつけます。結果は、2つのベクトルの方向がどれくらい「一致している」かを示します。

- もし同じ方向を向いていれば ($\theta = 0°$)、$\cos(\theta) = 1$ となりドット積は最大になります。

- もし直交していれば ($\theta = 90°$)、$\cos(\theta) = 0$ となりドット積はちょうどゼロになります。これにより、直交性を正確にテストできます。

- もし反対方向を向いていれば ($\theta = 180°$)、$\cos(\theta) = -1$ となりドット積は負になります。

- ベクトルの自分自身とのドット積は、その大きさの2乗になります： $\mathbf{a} \cdot \mathbf{a} = \|\mathbf{a}\|^2$。

- ドット積は **投影 (projection)** も与えてくれます。これは一方のベクトルがもう一方のベクトルの上に落とす「影」のようなものです。 $\mathbf{a}$ の $\mathbf{b}$ への投影は以下の通りです：

$$\text{proj}_{\mathbf{b}}(\mathbf{a}) = \frac{\mathbf{a} \cdot \mathbf{b}}{\|\mathbf{b}\|^2} \, \mathbf{b}$$

- $\mathbf{b}$ の上に光を真上から当てていると想像してください。その直線上に落ちる $\mathbf{a}$ の影が投影です。これは、$\mathbf{a}$ のうちどれくらいが $\mathbf{b}$ の方向に存在するかを教えてくれます。

- **コサイン類似度 (Cosine similarity)** は、ドット積をそれぞれの大きさで割ることで正規化したものです：

$$\cos(\theta) = \frac{\mathbf{a} \cdot \mathbf{b}}{\|\mathbf{a}\| \, \|\mathbf{b}\|}$$

- これにより、ベクトルの長さを無視して、方向の一致度を測定する $-1$ から $1$ の間の値が得られます。MLでは、ドキュメント、エンベディング、ユーザーの好みなどの比較に広く使用されています。

- さて、ドット積は2つのベクトルを受け取ってスカラーを返しました。**外積 (cross product)** はその反対で、2つのベクトルを受け取って _新しいベクトル_ を返します。

- 外積 $\mathbf{a} \times \mathbf{b}$ は、$\mathbf{a}$ と $\mathbf{b}$ の両方に対して垂直なベクトルを生成します：

$$\mathbf{a} \times \mathbf{b} = (a_2 b_3 - a_3 b_2, \; a_3 b_1 - a_1 b_3, \; a_1 b_2 - a_2 b_1)$$

- 外積は3次元空間でのみ定義されます。ドット積は任意の次元で機能しますが、外積は3次元空間特有のものです。

- その大きさは、2つのベクトルによって形成される平行四辺形の面積に等しくなります：

$$\|\mathbf{a} \times \mathbf{b}\| = \|\mathbf{a}\| \, \|\mathbf{b}\| \sin(\theta)$$

- パターンに注目してください。ドット積は $\cos(\theta)$ を使い、外積は $\sin(\theta)$ を使います。ドット積は2つのベクトルの「一致」を測り、外積は方向がいかに「異なっている」かを測ります。

- 結果の方向は **右手の法則** に従います。右手の指を $\mathbf{a}$ から $\mathbf{b}$ の方向へ丸めると、親指が $\mathbf{a} \times \mathbf{b}$ の方向を指します。

- ドット積とは異なり、外積は **交換法則が成り立ちません**: $\mathbf{a} \times \mathbf{b} = -(\mathbf{b} \times \mathbf{a})$。順番を入れ替えると方向が反転します。

- 2つのベクトルが平行な場合、それらの外積は零ベクトルになります ($\sin(0°) = 0$ のため)。面積も垂直な方向も存在しません。

- 3つのベクトルを両方の積を使って組み合わせるとどうなるでしょうか？これが **三重積 (triple products)** です。

- **スカラー三重積** $\mathbf{a} \cdot (\mathbf{b} \times \mathbf{c})$ は、まず2つのベクトルの外積を取り、その結果と第3のベクトルのドット積を取ります。出力は、3つのベクトルによって形成される平行六面体（傾いた3Dの箱）の体積に等しい一つの数値になります。

- もしスカラー三重積がゼロであれば、その3つのベクトルは **同一平面上 (coplanar)** にあります。それらはすべて同じ平らな面上にあり、体積を形成しません。

- 順序を循環させても結果は変わりません： $\mathbf{a} \cdot (\mathbf{b} \times \mathbf{c}) = \mathbf{b} \cdot (\mathbf{c} \times \mathbf{a}) = \mathbf{c} \cdot (\mathbf{a} \times \mathbf{b})$。

- **ベクトル三重積** $\mathbf{a} \times (\mathbf{b} \times \mathbf{c})$ は、外積を2回適用し、ベクトルを返します。これは以下の公式（項の再配列）できれいに展開できます：

$$\mathbf{a} \times (\mathbf{b} \times \mathbf{c}) = (\mathbf{a} \cdot \mathbf{c})\mathbf{b} - (\mathbf{a} \cdot \mathbf{b})\mathbf{c}$$

- 結果は常に $\mathbf{b}$ と $\mathbf{c}$ によって張られる平面内に位置します。なお、外積は **結合法則を満たしません**: $\mathbf{a} \times (\mathbf{b} \times \mathbf{c}) \neq (\mathbf{a} \times \mathbf{b}) \times \mathbf{c}$。

## コーディング課題 (CoLab または notebook を使用)

1. 2つのベクトルのドット積を計算し、それを使ってそれらの間の角度を求めてください。ベクトルを直交、平行、または反対方向にしてみて、角度がどのように変化するかを確認してください。

```python
import jax.numpy as jnp

a = jnp.array([1.0, 2.0, 3.0])
b = jnp.array([4.0, -1.0, 2.0])

dot = jnp.dot(a, b)
angle = jnp.arccos(dot / (jnp.linalg.norm(a) * jnp.linalg.norm(b)))

print(f"Dot product: {dot}")
print(f"Angle: {jnp.degrees(angle):.1f}°")
```

2. 2つの3次元ベクトルの外積を計算し、結果が元のそれぞれのベクトルと直交していることを、ドット積がゼロになることをチェックして確認してください。

```python
import jax.numpy as jnp

a = jnp.array([1.0, 0.0, 0.0])
b = jnp.array([0.0, 1.0, 0.0])

cross = jnp.cross(a, b)

print(f"a x b = {cross}")
print(f"Perpendicular to a: {jnp.dot(cross, a) == 0}")
print(f"Perpendicular to b: {jnp.dot(cross, b) == 0}")
```
